<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Nomination Pools for Staking Delegation"><meta name="keywords" content="rust, rustlang, rust-lang, pallet_nomination_pools"><title>pallet_nomination_pools - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-1d6438e53893d4f5.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../static.files/light-b8db113b98e15459.css"><link rel="stylesheet" disabled href="../static.files/dark-4b64df8497ac42b0.css"><link rel="stylesheet" disabled href="../static.files/ayu-4939169e939b96f8.css"><script id="default-settings" ></script><script src="../static.files/storage-d43fa987303ecbbb.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-8f89a77f33748381.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../pallet_nomination_pools/index.html"><div class="logo-container"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><h2></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../pallet_nomination_pools/index.html"><div class="logo-container"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><h2 class="location"><a href="#">Crate pallet_nomination_pools</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 1.0.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#constants">Constants</a></li><li><a href="#types">Type Definitions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-5ec35bf9ca753509.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Crate <a class="mod" href="#">pallet_nomination_pools</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/pallet_nomination_pools/lib.rs.html#18-2361">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="nomination-pools-for-staking-delegation"><a href="#nomination-pools-for-staking-delegation">Nomination Pools for Staking Delegation</a></h2>
<p>A pallet that allows members to delegate their stake to nominating pools. A nomination pool
acts as nominator and nominates validators on the members behalf.</p>
<h2 id="index"><a href="#index">Index</a></h2>
<ul>
<li><a href="#key-terms">Key terms</a></li>
<li><a href="#usage">Usage</a></li>
<li><a href="#design">Design</a></li>
</ul>
<h3 id="key-terms"><a href="#key-terms">Key terms</a></h3>
<ul>
<li>bonded pool: Tracks the distribution of actively staked funds. See <a href="struct.BondedPool.html" title="BondedPool"><code>BondedPool</code></a> and
<a href="struct.BondedPoolInner.html" title="BondedPoolInner"><code>BondedPoolInner</code></a>. Bonded pools are identified via the pools bonded account.</li>
<li>reward pool: Tracks rewards earned by actively staked funds. See <a href="struct.RewardPool.html" title="RewardPool"><code>RewardPool</code></a> and
<a href="pallet/type.RewardPools.html" title="RewardPools"><code>RewardPools</code></a>. Reward pools are identified via the pools bonded account.</li>
<li>unbonding sub pools: Collection of pools at different phases of the unbonding lifecycle. See
<a href="struct.SubPools.html" title="SubPools"><code>SubPools</code></a> and <a href="pallet/type.SubPoolsStorage.html" title="SubPoolsStorage"><code>SubPoolsStorage</code></a>. Sub pools are identified via the pools bonded account.</li>
<li>members: Accounts that are members of pools. See <a href="struct.PoolMember.html" title="PoolMember"><code>PoolMember</code></a> and <a href="pallet/type.PoolMembers.html" title="PoolMembers"><code>PoolMembers</code></a>. Pool
members are identified via their account.</li>
<li>point: A unit of measure for a members portion of a pool’s funds.</li>
<li>kick: The act of a pool administrator forcibly ejecting a member.</li>
</ul>
<h3 id="usage"><a href="#usage">Usage</a></h3><h4 id="join"><a href="#join">Join</a></h4>
<p>A account can stake funds with a nomination pool by calling <a href="pallet/enum.Call.html#variant.join" title="Call::join"><code>Call::join</code></a>.</p>
<h4 id="claim-rewards"><a href="#claim-rewards">Claim rewards</a></h4>
<p>After joining a pool, a member can claim rewards by calling <a href="pallet/enum.Call.html#variant.claim_payout" title="Call::claim_payout"><code>Call::claim_payout</code></a>.</p>
<p>For design docs see the <a href="#reward-pool">reward pool</a> section.</p>
<h4 id="leave"><a href="#leave">Leave</a></h4>
<p>In order to leave, a member must take two steps.</p>
<p>First, they must call <a href="pallet/enum.Call.html#variant.unbond" title="Call::unbond"><code>Call::unbond</code></a>. The unbond other extrinsic will start the
unbonding process by unbonding all of the members funds.</p>
<p>Second, once <a href="../sp_staking/trait.StakingInterface.html#tymethod.bonding_duration" title="sp_staking::StakingInterface::bonding_duration"><code>sp_staking::StakingInterface::bonding_duration</code></a> eras have passed, the member
can call <a href="pallet/enum.Call.html#variant.withdraw_unbonded" title="Call::withdraw_unbonded"><code>Call::withdraw_unbonded</code></a> to withdraw all their funds.</p>
<p>For design docs see the <a href="#bonded-pool">bonded pool</a> and <a href="#unbonding-sub-pools">unbonding sub
pools</a> sections.</p>
<h4 id="slashes"><a href="#slashes">Slashes</a></h4>
<p>Slashes are distributed evenly across the bonded pool and the unbonding pools from slash era+1
through the slash apply era. Thus, any member who either a) unbonded or b) was actively
bonded in the aforementioned range of eras will be affected by the slash. A member is slashed
pro-rata based on its stake relative to the total slash amount.</p>
<p>For design docs see the <a href="#slashing">slashing</a> section.</p>
<h4 id="administration"><a href="#administration">Administration</a></h4>
<p>A pool can be created with the <a href="pallet/enum.Call.html#variant.create" title="Call::create"><code>Call::create</code></a> call. Once created, the pools nominator or root
user must call <a href="pallet/enum.Call.html#variant.nominate" title="Call::nominate"><code>Call::nominate</code></a> to start nominating. <a href="pallet/enum.Call.html#variant.nominate" title="Call::nominate"><code>Call::nominate</code></a> can be called at
anytime to update validator selection.</p>
<p>To help facilitate pool administration the pool has one of three states (see <a href="enum.PoolState.html" title="PoolState"><code>PoolState</code></a>):</p>
<ul>
<li>Open: Anyone can join the pool and no members can be permissionlessly removed.</li>
<li>Blocked: No members can join and some admin roles can kick members.</li>
<li>Destroying: No members can join and all members can be permissionlessly removed with
<a href="pallet/enum.Call.html#variant.unbond" title="Call::unbond"><code>Call::unbond</code></a> and <a href="pallet/enum.Call.html#variant.withdraw_unbonded" title="Call::withdraw_unbonded"><code>Call::withdraw_unbonded</code></a>. Once a pool is in destroying state, it
cannot be reverted to another state.</li>
</ul>
<p>A pool has 3 administrative roles (see <a href="struct.PoolRoles.html" title="PoolRoles"><code>PoolRoles</code></a>):</p>
<ul>
<li>Depositor: creates the pool and is the initial member. They can only leave the pool once all
other members have left. Once they fully leave the pool is destroyed.</li>
<li>Nominator: can select which validators the pool nominates.</li>
<li>State-Toggler: can change the pools state and kick members if the pool is blocked.</li>
<li>Root: can change the nominator, state-toggler, or itself and can perform any of the actions
the nominator or state-toggler can.</li>
</ul>
<h3 id="design"><a href="#design">Design</a></h3>
<p><em>Notes</em>: this section uses pseudo code to explain general design and does not necessarily
reflect the exact implementation. Additionally, a working knowledge of <code>pallet-staking</code>’s api is
assumed.</p>
<h4 id="goals"><a href="#goals">Goals</a></h4>
<ul>
<li>Maintain network security by upholding integrity of slashing events, sufficiently penalizing
members that where in the pool while it was backing a validator that got slashed.</li>
<li>Maximize scalability in terms of member count.</li>
</ul>
<p>In order to maintain scalability, all operations are independent of the number of members. To
do this, delegation specific information is stored local to the member while the pool data
structures have bounded datum.</p>
<h4 id="bonded-pool"><a href="#bonded-pool">Bonded pool</a></h4>
<p>A bonded pool nominates with its total balance, excluding that which has been withdrawn for
unbonding. The total points of a bonded pool are always equal to the sum of points of the
delegation members. A bonded pool tracks its points and reads its bonded balance.</p>
<p>When a member joins a pool, <code>amount_transferred</code> is transferred from the members account
to the bonded pools account. Then the pool calls <code>staking::bond_extra(amount_transferred)</code> and
issues new points which are tracked by the member and added to the bonded pool’s points.</p>
<p>When the pool already has some balance, we want the value of a point before the transfer to
equal the value of a point after the transfer. So, when a member joins a bonded pool with a
given <code>amount_transferred</code>, we maintain the ratio of bonded balance to points such that:</p>
<div class="example-wrap"><pre class="language-text"><code>balance_after_transfer / points_after_transfer == balance_before_transfer / points_before_transfer;</code></pre></div>
<p>To achieve this, we issue points based on the following:</p>
<div class="example-wrap"><pre class="language-text"><code>points_issued = (points_before_transfer / balance_before_transfer) * amount_transferred;</code></pre></div>
<p>For new bonded pools we can set the points issued per balance arbitrarily. In this
implementation we use a 1 points to 1 balance ratio for pool creation (see
<a href="constant.POINTS_TO_BALANCE_INIT_RATIO.html" title="POINTS_TO_BALANCE_INIT_RATIO"><code>POINTS_TO_BALANCE_INIT_RATIO</code></a>).</p>
<p><strong>Relevant extrinsics:</strong></p>
<ul>
<li><a href="pallet/enum.Call.html#variant.create" title="Call::create"><code>Call::create</code></a></li>
<li><a href="pallet/enum.Call.html#variant.join" title="Call::join"><code>Call::join</code></a></li>
</ul>
<h4 id="reward-pool"><a href="#reward-pool">Reward pool</a></h4>
<p>When a pool is first bonded it sets up an deterministic, inaccessible account as its reward
destination. To track staking rewards we track how the balance of this reward account changes.</p>
<p>The reward pool needs to store:</p>
<ul>
<li>The pool balance at the time of the last payout: <code>reward_pool.balance</code></li>
<li>The total earnings ever at the time of the last payout: <code>reward_pool.total_earnings</code></li>
<li>The total points in the pool at the time of the last payout: <code>reward_pool.points</code></li>
</ul>
<p>And the member needs to store:</p>
<ul>
<li>The total payouts at the time of the last payout by that member:
<code>member.reward_pool_total_earnings</code></li>
</ul>
<p>Before the first reward claim is initiated for a pool, all the above variables are set to zero.</p>
<p>When a member initiates a claim, the following happens:</p>
<ol>
<li>Compute the reward pool’s total points and the member’s virtual points in the reward pool
<ul>
<li>First <code>current_total_earnings</code> is computed (<code>current_balance</code> is the free balance of the
reward pool at the beginning of these operations.)<div class="example-wrap"><pre class="language-text"><code>current_total_earnings =
	current_balance - reward_pool.balance + pool.total_earnings;</code></pre></div></li>
<li>Then the <code>current_points</code> is computed. Every balance unit that was added to the reward
pool since last time recorded means that the <code>pool.points</code> is increased by
<code>bonding_pool.total_points</code>. In other words, for every unit of balance that has been
earned by the reward pool, the reward pool points are inflated by <code>bonded_pool.points</code>. In
effect this allows each, single unit of balance (e.g. planck) to be divvied up pro-rata
among members based on points.<div class="example-wrap"><pre class="language-text"><code>new_earnings = current_total_earnings - reward_pool.total_earnings;
current_points = reward_pool.points + bonding_pool.points * new_earnings;</code></pre></div></li>
<li>Finally, the<code>member_virtual_points</code> are computed: the product of the member’s points in
the bonding pool and the total inflow of balance units since the last time the member
claimed rewards<div class="example-wrap"><pre class="language-text"><code>new_earnings_since_last_claim = current_total_earnings - member.reward_pool_total_earnings;
member_virtual_points = member.points * new_earnings_since_last_claim;</code></pre></div></li>
</ul>
</li>
<li>Compute the <code>member_payout</code>:<div class="example-wrap"><pre class="language-text"><code>member_pool_point_ratio = member_virtual_points / current_points;
member_payout = current_balance * member_pool_point_ratio;</code></pre></div></li>
<li>Transfer <code>member_payout</code> to the member</li>
<li>For the member set:<div class="example-wrap"><pre class="language-text"><code>member.reward_pool_total_earnings = current_total_earnings;</code></pre></div></li>
<li>For the pool set:<div class="example-wrap"><pre class="language-text"><code>reward_pool.points = current_points - member_virtual_points;
reward_pool.balance = current_balance - member_payout;
reward_pool.total_earnings = current_total_earnings;</code></pre></div></li>
</ol>
<p><em>Note</em>: One short coming of this design is that new joiners can claim rewards for the era after
they join even though their funds did not contribute to the pools vote weight. When a
member joins, it’s <code>reward_pool_total_earnings</code> field is set equal to the <code>total_earnings</code>
of the reward pool at that point in time. At best the reward pool has the rewards up through the
previous era. If a member joins prior to the election snapshot it will benefit from the
rewards for the active era despite not contributing to the pool’s vote weight. If it joins
after the election snapshot is taken it will benefit from the rewards of the next <em>2</em> eras
because it’s vote weight will not be counted until the election snapshot in active era + 1.
Related: <a href="https://github.com/paritytech/substrate/issues/10861">https://github.com/paritytech/substrate/issues/10861</a></p>
<p><strong>Relevant extrinsics:</strong></p>
<ul>
<li><a href="pallet/enum.Call.html#variant.claim_payout" title="Call::claim_payout"><code>Call::claim_payout</code></a></li>
</ul>
<h4 id="unbonding-sub-pools"><a href="#unbonding-sub-pools">Unbonding sub pools</a></h4>
<p>When a member unbonds, it’s balance is unbonded in the bonded pool’s account and tracked in
an unbonding pool associated with the active era. If no such pool exists, one is created. To
track which unbonding sub pool a member belongs too, a member tracks it’s
<code>unbonding_era</code>.</p>
<p>When a member initiates unbonding it’s claim on the bonded pool
(<code>balance_to_unbond</code>) is computed as:</p>
<div class="example-wrap"><pre class="language-text"><code>balance_to_unbond = (bonded_pool.balance / bonded_pool.points) * member.points;</code></pre></div>
<p>If this is the first transfer into an unbonding pool arbitrary amount of points can be issued
per balance. In this implementation unbonding pools are initialized with a 1 point to 1 balance
ratio (see <a href="constant.POINTS_TO_BALANCE_INIT_RATIO.html" title="POINTS_TO_BALANCE_INIT_RATIO"><code>POINTS_TO_BALANCE_INIT_RATIO</code></a>). Otherwise, the unbonding pools hold the same
points to balance ratio properties as the bonded pool, so member points in the
unbonding pool are issued based on</p>
<div class="example-wrap"><pre class="language-text"><code>new_points_issued = (points_before_transfer / balance_before_transfer) * balance_to_unbond;</code></pre></div>
<p>For scalability, a bound is maintained on the number of unbonding sub pools (see
<a href="struct.TotalUnbondingPools.html" title="TotalUnbondingPools"><code>TotalUnbondingPools</code></a>). An unbonding pool is removed once its older than <code>current_era - TotalUnbondingPools</code>. An unbonding pool is merged into the unbonded pool with</p>
<div class="example-wrap"><pre class="language-text"><code>unbounded_pool.balance = unbounded_pool.balance + unbonding_pool.balance;
unbounded_pool.points = unbounded_pool.points + unbonding_pool.points;</code></pre></div>
<p>This scheme “averages” out the points value in the unbonded pool.</p>
<p>Once a members <code>unbonding_era</code> is older than <code>current_era - [sp_staking::StakingInterface::bonding_duration]</code>, it can can cash it’s points out of the
corresponding unbonding pool. If it’s <code>unbonding_era</code> is older than <code>current_era - TotalUnbondingPools</code>, it can cash it’s points from the unbonded pool.</p>
<p><strong>Relevant extrinsics:</strong></p>
<ul>
<li><a href="pallet/enum.Call.html#variant.unbond" title="Call::unbond"><code>Call::unbond</code></a></li>
<li><a href="pallet/enum.Call.html#variant.withdraw_unbonded" title="Call::withdraw_unbonded"><code>Call::withdraw_unbonded</code></a></li>
</ul>
<h4 id="slashing"><a href="#slashing">Slashing</a></h4>
<p>This section assumes that the slash computation is executed by
<code>pallet_staking::StakingLedger::slash</code>, which passes the information to this pallet via
<a href="../sp_staking/trait.OnStakerSlash.html#tymethod.on_slash" title="sp_staking::OnStakerSlash::on_slash"><code>sp_staking::OnStakerSlash::on_slash</code></a>.</p>
<p>Unbonding pools need to be slashed to ensure all nominators whom where in the bonded pool
while it was backing a validator that equivocated are punished. Without these measures a
member could unbond right after a validator equivocated with no consequences.</p>
<p>This strategy is unfair to members who joined after the slash, because they get slashed as
well, but spares members who unbond. The latter is much more important for security: if a
pool’s validators are attacking the network, their members need to unbond fast! Avoiding
slashes gives them an incentive to do that if validators get repeatedly slashed.</p>
<p>To be fair to joiners, this implementation also need joining pools, which are actively staking,
in addition to the unbonding pools. For maintenance simplicity these are not implemented.
Related: <a href="https://github.com/paritytech/substrate/issues/10860">https://github.com/paritytech/substrate/issues/10860</a></p>
<p><strong>Relevant methods:</strong></p>
<ul>
<li><a href="pallet/struct.Pallet.html#method.on_slash" title="Pallet::on_slash"><code>Pallet::on_slash</code></a></li>
</ul>
<h4 id="limitations"><a href="#limitations">Limitations</a></h4>
<ul>
<li>PoolMembers cannot vote with their staked funds because they are transferred into the pools
account. In the future this can be overcome by allowing the members to vote with their bonded
funds via vote splitting.</li>
<li>PoolMembers cannot quickly transfer to another pool if they do no like nominations, instead
they must wait for the unbonding duration.</li>
</ul>
<h2 id="runtime-builder-warnings"><a href="#runtime-builder-warnings">Runtime builder warnings</a></h2>
<ul>
<li>Watch out for overflow of <a href="type.RewardPoints.html" title="RewardPoints"><code>RewardPoints</code></a> and <a href="type.BalanceOf.html" title="BalanceOf"><code>BalanceOf</code></a> types. Consider things like the
chains total issuance, staking reward rate, and burn rate.</li>
</ul>
</div></details><h2 id="reexports" class="small-section-header"><a href="#reexports">Re-exports</a></h2><div class="item-table"><div class="item-row"><div class="item-left import-item" id="reexport.WeightInfo"><code>pub use weights::<a class="trait" href="weights/trait.WeightInfo.html" title="trait pallet_nomination_pools::weights::WeightInfo">WeightInfo</a>;</code></div></div><div class="item-row"><div class="item-left import-item"><code>pub use <a class="mod" href="pallet/index.html" title="mod pallet_nomination_pools::pallet">pallet</a>::*;</code></div></div></div><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="mod" href="migration/index.html" title="pallet_nomination_pools::migration mod">migration</a></div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="pallet/index.html" title="pallet_nomination_pools::pallet mod">pallet</a></div><div class="item-right docblock-short">The module that hosts all the
<a href="https://docs.substrate.io/v3/runtime/frame">FRAME</a>
types needed to add this pallet to a
runtime.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="weights/index.html" title="pallet_nomination_pools::weights mod">weights</a></div><div class="item-right docblock-short">Autogenerated weights for pallet_nomination_pools</div></div></div><h2 id="macros" class="small-section-header"><a href="#macros">Macros</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.log.html" title="pallet_nomination_pools::log macro">log</a></div></div></div><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.BondedPool.html" title="pallet_nomination_pools::BondedPool struct">BondedPool</a></div><div class="item-right docblock-short">A wrapper for bonded pools, with utility functions.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.BondedPoolInner.html" title="pallet_nomination_pools::BondedPoolInner struct">BondedPoolInner</a></div><div class="item-right docblock-short">Pool permissions and state</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.PoolMember.html" title="pallet_nomination_pools::PoolMember struct">PoolMember</a></div><div class="item-right docblock-short">A member in a pool.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.PoolRoles.html" title="pallet_nomination_pools::PoolRoles struct">PoolRoles</a></div><div class="item-right docblock-short">Pool administration roles.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.RewardPool.html" title="pallet_nomination_pools::RewardPool struct">RewardPool</a></div><div class="item-right docblock-short">A reward pool.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.SubPools.html" title="pallet_nomination_pools::SubPools struct">SubPools</a></div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.TotalUnbondingPools.html" title="pallet_nomination_pools::TotalUnbondingPools struct">TotalUnbondingPools</a></div><div class="item-right docblock-short">The maximum amount of eras an unbonding pool can exist prior to being merged with the
<code>no_era</code> pool. This is guaranteed to at least be equal to the staking <code>UnbondingDuration</code>. For
improved UX <a href="pallet/trait.Config.html#associatedtype.PostUnbondingPoolsWindow" title="Config::PostUnbondingPoolsWindow"><code>Config::PostUnbondingPoolsWindow</code></a> should be configured to a non-zero value.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.UnbondPool.html" title="pallet_nomination_pools::UnbondPool struct">UnbondPool</a></div><div class="item-right docblock-short">An unbonding pool. This is always mapped with an era.</div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.BondExtra.html" title="pallet_nomination_pools::BondExtra enum">BondExtra</a></div><div class="item-right docblock-short">How to increase the bond of a member.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.ConfigOp.html" title="pallet_nomination_pools::ConfigOp enum">ConfigOp</a></div><div class="item-right docblock-short">Possible operations on the configuration values of this pallet.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.PoolState.html" title="pallet_nomination_pools::PoolState enum">PoolState</a></div><div class="item-right docblock-short">A pool’s possible states.</div></div></div><h2 id="constants" class="small-section-header"><a href="#constants">Constants</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant.LOG_TARGET.html" title="pallet_nomination_pools::LOG_TARGET constant">LOG_TARGET</a></div><div class="item-right docblock-short">The log target of this pallet.</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant.POINTS_TO_BALANCE_INIT_RATIO.html" title="pallet_nomination_pools::POINTS_TO_BALANCE_INIT_RATIO constant">POINTS_TO_BALANCE_INIT_RATIO</a></div></div></div><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="type" href="type.BalanceOf.html" title="pallet_nomination_pools::BalanceOf type">BalanceOf</a></div><div class="item-right docblock-short">The balance type used by the currency system.</div></div><div class="item-row"><div class="item-left module-item"><a class="type" href="type.PoolId.html" title="pallet_nomination_pools::PoolId type">PoolId</a></div><div class="item-right docblock-short">Type used for unique identifier of each pool.</div></div><div class="item-row"><div class="item-left module-item"><a class="type" href="type.RewardPoints.html" title="pallet_nomination_pools::RewardPoints type">RewardPoints</a></div><div class="item-right docblock-short">Type used to track the points of a reward pool.</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="pallet_nomination_pools" data-themes="" data-resource-suffix="" data-rustdoc-version="1.67.0-nightly (c5d82ed7a 2022-11-19)" data-search-js="search-df80cc3cb87b6482.js" data-settings-js="settings-7e1cf5cc683233f7.js" data-settings-css="settings-af96d9e2fc13e081.css" ></div></body></html>